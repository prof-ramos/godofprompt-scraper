---
description: Sistema de logging e tratamento de erros robusto
---

# ðŸ“ Logging e Tratamento de Erros

Sistema completo para **monitoramento** e **depuraÃ§Ã£o** do scraper de prompts.

## ðŸŽ¯ ImportÃ¢ncia do Logging

### BenefÃ­cios
- **Rastreamento** de execuÃ§Ã£o em tempo real
- **DiagnÃ³stico** rÃ¡pido de problemas
- **Auditoria** de resultados
- **Monitoramento** de performance
- **Debug** sem reinicializar

### NÃ­veis de Log
```python
import logging

# DEBUG: Detalhes tÃ©cnicos para desenvolvimento
logging.debug("Elemento encontrado: [wized='plp_prompt_item_all']")

# INFO: Progresso normal da execuÃ§Ã£o
logging.info(f"PÃ¡gina {page}: {len(prompts)} prompts extraÃ­dos")

# WARNING: SituaÃ§Ãµes nÃ£o crÃ­ticas
logging.warning("PÃ¡gina carregada mas sem prompts visÃ­veis")

# ERROR: Problemas que impedem continuaÃ§Ã£o
logging.error(f"Falha na extraÃ§Ã£o da categoria {category}: {str(e)}")

# CRITICAL: Erros graves que param execuÃ§Ã£o
logging.critical("Driver do Chrome falhou - abortando extraÃ§Ã£o")
```

## âš™ï¸ ConfiguraÃ§Ã£o do Sistema de Log

### ConfiguraÃ§Ã£o BÃ¡sica
```python
def setup_logging():
    """Configura o sistema de logging completo."""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            # Log em arquivo
            logging.FileHandler('extraction_log.txt', encoding='utf-8'),
            # Log no console
            logging.StreamHandler()
        ]
    )

    # Configurar nÃ­vel para bibliotecas externas
    logging.getLogger('selenium').setLevel(logging.WARNING)
    logging.getLogger('urllib3').setLevel(logging.WARNING)
```

### FormataÃ§Ã£o AvanÃ§ada
```python
# Formato mais detalhado
formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'
)

# Handler para arquivo com rotaÃ§Ã£o
from logging.handlers import RotatingFileHandler

file_handler = RotatingFileHandler(
    'extraction_log.txt',
    maxBytes=10*1024*1024,  # 10MB
    backupCount=5
)
file_handler.setFormatter(formatter)
```

## ðŸš¨ Tratamento de Erros Robusto

### Estrutura Base com Try-Except-Finally
```python
def extract_category_links(category):
    """ExtraÃ§Ã£o com tratamento completo de erros."""
    driver = None
    start_time = time.time()

    try:
        logging.info(f"ðŸš€ Iniciando extraÃ§Ã£o: {category['nome']}")

        driver = create_driver()
        results = []

        # LÃ³gica principal aqui
        results = perform_extraction(driver, category)

        execution_time = time.time() - start_time
        logging.info(".2f"
        return results

    except KeyboardInterrupt:
        logging.warning(f"âš ï¸  ExtraÃ§Ã£o interrompida pelo usuÃ¡rio: {category['nome']}")
        return []

    except Exception as e:
        execution_time = time.time() - start_time
        logging.error(".2f"        logging.error(f"Stack trace: {traceback.format_exc()}")
        return []

    finally:
        if driver:
            driver.quit()
            logging.debug("Driver fechado com sucesso")
```

### Tipos de ExceÃ§Ãµes EspecÃ­ficas
```python
from selenium.common.exceptions import (
    TimeoutException,
    NoSuchElementException,
    WebDriverException,
    StaleElementReferenceException
)

try:
    element = driver.find_element(By.CSS_SELECTOR, selector)
except TimeoutException:
    logging.error("Timeout aguardando elemento")
except NoSuchElementException:
    logging.error(f"Elemento nÃ£o encontrado: {selector}")
except WebDriverException as e:
    logging.error(f"Erro do WebDriver: {e}")
except StaleElementReferenceException:
    logging.warning("Elemento ficou stale - tentando novamente")
```

## ðŸ“Š MÃ©tricas e Monitoramento

### Contadores de Performance
```python
class ExtractionMetrics:
    def __init__(self):
        self.categories_processed = 0
        self.prompts_extracted = 0
        self.errors_encountered = 0
        self.start_time = time.time()

    def log_progress(self, category_name, prompts_count):
        self.categories_processed += 1
        self.prompts_extracted += prompts_count

        elapsed = time.time() - self.start_time
        avg_time = elapsed / self.categories_processed

        logging.info(f"ðŸ“Š Progresso: {self.categories_processed} categorias processadas")
        logging.info(f"ðŸ“ˆ Total de prompts: {self.prompts_extracted}")
        logging.info(".2f"
    def log_error(self, error_type, details):
        self.errors_encountered += 1
        logging.error(f"âŒ Erro {self.errors_encountered}: {error_type} - {details}")
```

### RelatÃ³rio Final
```python
def generate_final_report(metrics, results):
    """Gera relatÃ³rio completo da extraÃ§Ã£o."""
    report = {
        'timestamp': datetime.now().isoformat(),
        'total_execution_time': time.time() - metrics.start_time,
        'categories_processed': metrics.categories_processed,
        'total_prompts': metrics.prompts_extracted,
        'errors': metrics.errors_encountered,
        'success_rate': calculate_overall_success_rate(results),
        'category_breakdown': {}
    }

    for cat_name, data in results.items():
        report['category_breakdown'][cat_name] = {
            'prompts_extracted': len(data['prompts']),
            'expected': data['quantidade_esperada'],
            'success_rate': (len(data['prompts']) / data['quantidade_esperada']) * 100
        }

    # Salvar relatÃ³rio
    with open('extraction_report.json', 'w', encoding='utf-8') as f:
        json.dump(report, f, ensure_ascii=False, indent=2)

    return report
```

## ðŸ”§ Debugging e Troubleshooting

### Captura de Screenshots
```python
def capture_error_screenshot(driver, error_type, category_name):
    """Captura screenshot em caso de erro."""
    try:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"error_{error_type}_{category_name}_{timestamp}.png"
        driver.save_screenshot(filename)
        logging.info(f"Screenshot salvo: {filename}")
    except Exception as e:
        logging.error(f"Falha ao salvar screenshot: {e}")
```

### AnÃ¡lise de HTML para Debug
```python
def save_debug_html(driver, filename):
    """Salva HTML da pÃ¡gina para anÃ¡lise."""
    try:
        html = driver.page_source
        with open(f"debug_{filename}.html", 'w', encoding='utf-8') as f:
            f.write(html)
        logging.info(f"HTML de debug salvo: debug_{filename}.html")
    except Exception as e:
        logging.error(f"Falha ao salvar HTML de debug: {e}")
```

### VerificaÃ§Ã£o de Elementos
```python
def debug_element_presence(driver, selectors):
    """Verifica presenÃ§a de elementos para debug."""
    for selector in selectors:
        try:
            elements = driver.find_elements(By.CSS_SELECTOR, selector)
            logging.debug(f"Selector '{selector}': {len(elements)} elementos encontrados")
        except Exception as e:
            logging.debug(f"Erro verificando selector '{selector}': {e}")
```

## âš¡ PadrÃµes de ResiliÃªncia

### Retry Mechanism
```python
import tenacity

@tenacity.retry(
    stop=tenacity.stop_after_attempt(3),
    wait=tenacity.wait_exponential(multiplier=1, min=4, max=10),
    retry=tenacity.retry_if_exception_type((TimeoutException, WebDriverException))
)
def robust_page_load(driver, url):
    """Carregamento de pÃ¡gina com retry automÃ¡tico."""
    logging.info(f"Carregando: {url}")
    driver.get(url)

    if not wait_for_prompts_to_load(driver):
        raise Exception("Falha no carregamento da pÃ¡gina")
```

### Circuit Breaker
```python
class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout=60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failures = 0
        self.last_failure = 0

    def should_attempt(self):
        if self.failures >= self.failure_threshold:
            if time.time() - self.last_failure < self.timeout:
                return False
            else:
                # Reset after timeout
                self.failures = 0
        return True

    def record_success(self):
        self.failures = 0

    def record_failure(self):
        self.failures += 1
        self.last_failure = time.time()
```

### Graceful Degradation
```python
def extract_with_fallback(driver, category):
    """ExtraÃ§Ã£o com estratÃ©gias de fallback."""
    strategies = [
        extract_with_selenium,
        extract_with_requests_fallback,
        extract_minimal_data
    ]

    for strategy in strategies:
        try:
            logging.info(f"Tentando estratÃ©gia: {strategy.__name__}")
            return strategy(driver, category)
        except Exception as e:
            logging.warning(f"EstratÃ©gia {strategy.__name__} falhou: {e}")
            continue

    logging.error("Todas as estratÃ©gias falharam")
    return []
```

## ðŸ“‹ Checklist de Qualidade

### Antes de Executar
- [ ] Logging configurado corretamente
- [ ] NÃ­veis de log apropriados
- [ ] Handlers configurados (arquivo + console)
- [ ] Tratamento de exceÃ§Ãµes implementado
- [ ] MÃ©tricas de performance ativas

### Durante a ExecuÃ§Ã£o
- [ ] Logs sendo gravados regularmente
- [ ] Progresso sendo reportado
- [ ] Erros sendo capturados e logados
- [ ] Screenshots salvos em caso de falha
- [ ] Recursos sendo liberados corretamente

### ApÃ³s a ExecuÃ§Ã£o
- [ ] RelatÃ³rio final gerado
- [ ] Logs analisados para melhorias
- [ ] MÃ©tricas consolidadas
- [ ] Problemas identificados e documentados