---
description: T√©cnicas avan√ßadas de web scraping com Selenium
---

# üåê Web Scraping Avan√ßado - Selenium

Este projeto utiliza **Selenium WebDriver** para extrair dados din√¢micos do site godofprompt.ai.

## üéØ Por que Selenium?

### Sites Din√¢micos
O godofprompt.ai usa **JavaScript** para carregar conte√∫do:
- Prompts s√£o carregados via AJAX
- Pagina√ß√£o √© controlada por JavaScript
- Conte√∫do depende de execu√ß√£o de scripts

### Vantagens sobre Requests + BeautifulSoup
- ‚úÖ Renderiza JavaScript completamente
- ‚úÖ Interage com elementos din√¢micos
- ‚úÖ Lida com Single Page Applications (SPA)
- ‚úÖ Suporte a cookies e sess√µes

## ‚öôÔ∏è Configura√ß√£o do Chrome Driver

### Op√ß√µes Essenciais
```python
from selenium.webdriver.chrome.options import Options

def create_driver():
    chrome_options = Options()

    # Execu√ß√£o em background
    chrome_options.add_argument("--headless")
    chrome_options.add_argument("--no-sandbox")
    chrome_options.add_argument("--disable-dev-shm-usage")
    chrome_options.add_argument("--disable-gpu")

    # Janela de tamanho fixo
    chrome_options.add_argument("--window-size=1920,1080")

    # User-Agent realista
    chrome_options.add_argument("--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36")

    # Anti-detec√ß√£o de bot
    chrome_options.add_argument("--disable-blink-features=AutomationControlled")
    chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
    chrome_options.add_experimental_option('useAutomationExtension', False)

    return webdriver.Chrome(options=chrome_options)
```

## üîç Seletores Espec√≠ficos do Site

### Elementos Wized
O site usa **Wized** para conte√∫do din√¢mico:
```javascript
// Todos os prompts da p√°gina
'[wized="plp_prompt_item_all"]'

// Link do prompt
'[wized="plp_prompt_item_link"]'

// Nome do prompt
'[wized="plp_prompt_name"]'

// ID do prompt
'[wized="plp_prompt_id"]'
```

### Controles de Pagina√ß√£o
```javascript
// Bot√£o pr√≥ximo
'[wized="pagin-next"]'

// P√°gina atual
'[wized="pagin-cur-page"]'

// Total de p√°ginas
'[wized="pagin-all-pages"]'
```

## üìú Scripts JavaScript para Extra√ß√£o

### Extrair Dados de uma P√°gina
```python
def extract_prompts_from_page(driver):
    script = """
    return Array.from(document.querySelectorAll('[wized="plp_prompt_item_all"]')).map(el => {
        const linkElement = el.querySelector('[wized="plp_prompt_item_link"]');
        const nameElement = el.querySelector('[wized="plp_prompt_name"]');
        const idElement = el.querySelector('[wized="plp_prompt_id"]');

        return {
            url: linkElement ? linkElement.href : null,
            name: nameElement ? nameElement.textContent.trim() : '',
            id: idElement ? idElement.textContent.trim() : '',
            category: window.location.search.includes('category=') ?
                new URLSearchParams(window.location.search).get('category') : 'unknown'
        };
    });
    """

    prompts = driver.execute_script(script)
    return [p for p in prompts if p['url'] and p['url'] != '#']
```

### Verificar Pagina√ß√£o
```python
def get_pagination_info(driver):
    script = """
    const nextBtn = document.querySelector('[wized="pagin-next"]');
    const currentPageEl = document.querySelector('[wized="pagin-cur-page"]');
    const totalPagesEl = document.querySelector('[wized="pagin-all-pages"]');

    return {
        hasNext: nextBtn && !nextBtn.disabled && nextBtn.style.display !== 'none',
        currentPage: currentPageEl ? parseInt(currentPageEl.textContent) : 1,
        totalPages: totalPagesEl ? parseInt(totalPagesEl.textContent) : 1
    };
    """

    return driver.execute_script(script)
```

## ‚è±Ô∏è Esperas Inteligentes

### Aguardar Carregamento Din√¢mico
```python
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

def wait_for_prompts_to_load(driver, timeout=30):
    """Aguarda o carregamento dos prompts na p√°gina."""
    try:
        WebDriverWait(driver, timeout).until(
            lambda d: d.execute_script(
                "return document.querySelectorAll('[wized=\"plp_prompt_item_all\"]').length > 0"
            )
        )
        time.sleep(2)  # Espera extra para estabilidade
        return True
    except Exception as e:
        logging.error(f"Timeout aguardando prompts: {e}")
        return False
```

### Aguardar Elemento Clic√°vel
```python
def click_next_page(driver):
    """Clica no bot√£o 'pr√≥ximo' com verifica√ß√£o de clicabilidade."""
    try:
        next_button = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, '[wized="pagin-next"]'))
        )
        next_button.click()
        time.sleep(3)  # Aguardar carregamento da nova p√°gina
        return True
    except Exception as e:
        logging.error(f"Erro ao clicar pr√≥ximo: {e}")
        return False
```

## üöÄ Estrat√©gias de Navega√ß√£o

### Navega√ß√£o por Categoria
```python
def extract_category_links(category, driver=None):
    if driver is None:
        driver = create_driver()

    try:
        # Carregar p√°gina inicial
        driver.get(category['link'])

        # Aguardar carregamento
        if not wait_for_prompts_to_load(driver):
            return []

        # Extrair primeira p√°gina
        all_prompts = extract_prompts_from_page(driver)

        # Navegar p√°ginas restantes
        pagination = get_pagination_info(driver)

        for page in range(2, min(pagination['totalPages'] + 1, 51)):  # M√°x 50 p√°ginas
            if not click_next_page(driver):
                break

            if not wait_for_prompts_to_load(driver):
                break

            new_prompts = extract_prompts_from_page(driver)

            # Evitar duplicatas
            for prompt in new_prompts:
                if not any(p['url'] == prompt['url'] for p in all_prompts):
                    all_prompts.append(prompt)

        return all_prompts

    finally:
        if driver:
            driver.quit()
```

## üõ°Ô∏è Anti-Detec√ß√£o e Robustez

### Headers e User-Agent
```python
chrome_options.add_argument(
    "--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36"
)
```

### Pausas Estrat√©gicas
```python
# Entre categorias
time.sleep(2)

# Ap√≥s carregamento de p√°gina
time.sleep(3)

# Entre cliques
time.sleep(1)
```

### Tratamento de Timeouts
```python
try:
    WebDriverWait(driver, 20).until(condition)
except TimeoutException:
    logging.warning("Timeout - tentando abordagem alternativa")
    # Fallback strategy
```

## üìä Monitoramento e Debugging

### Screenshot para Debug
```python
def take_screenshot(driver, filename):
    """Salva screenshot para an√°lise."""
    driver.save_screenshot(f"debug_{filename}.png")
```

### Logs Detalhados
```python
logging.info(f"P√°gina {page}: {len(new_prompts)} prompts encontrados")
logging.error(f"Falha na extra√ß√£o da categoria {category['nome']}")
```

## üîß Troubleshooting Comum

### Problema: Elementos n√£o encontrados
```python
# Verificar se o seletor mudou
current_html = driver.page_source
with open('debug_page.html', 'w') as f:
    f.write(current_html)
```

### Problema: Timeout frequente
```python
# Aumentar timeouts
WebDriverWait(driver, 60).until(condition)

# Ou reduzir frequ√™ncia de requests
time.sleep(5)
```

### Problema: Driver crash
```python
# Reinicializar driver
if driver:
    driver.quit()
driver = create_driver()
```

## üìà Otimiza√ß√µes de Performance

### Reutiliza√ß√£o do Driver
```python
# Mesmo driver para m√∫ltiplas categorias
driver = create_driver()
for category in categories:
    results = extract_category_links(category, driver=driver)
```

### Processamento Paralelo
```python
from concurrent.futures import ThreadPoolExecutor

def extract_multiple_categories(categories):
    with ThreadPoolExecutor(max_workers=3) as executor:
        futures = [executor.submit(extract_category_links, cat) for cat in categories]
        return [future.result() for future in futures]
```

### Limita√ß√£o de Recursos
```python
# M√°ximo de p√°ginas por categoria
max_pages = min(total_pages, 50)

# Timeout global
driver.set_page_load_timeout(30)
```