# üõ°Ô∏è Guia de Qualidade de C√≥digo - GodOfPrompt Scraper

## üìã Vis√£o Geral

Este guia estabelece os padr√µes de qualidade de c√≥digo para o projeto GodOfPrompt Scraper, integrando ferramentas automatizadas de linting, formata√ß√£o e revis√£o de c√≥digo.

## üõ†Ô∏è Ferramentas de Qualidade

### uv (Gerenciador de Pacotes)

#### Por que uv?
O **uv** √© o gerenciador de pacotes Python mais r√°pido dispon√≠vel, oferecendo:

- ‚ö° **Performance excepcional**: At√© 10x mais r√°pido que pip
- üîÑ **Gerenciamento autom√°tico**: Ambientes virtuais criados automaticamente
- üì¶ **Resolu√ß√£o inteligente**: Algoritmos avan√ßados para resolu√ß√£o de depend√™ncias
- üîí **Seguran√ßa**: Verifica√ß√µes de integridade e hash
- üíæ **Cache eficiente**: Reutiliza√ß√£o inteligente de downloads

#### Instala√ß√£o e Uso
```bash
# Instalar uv
curl -LsSf https://astral.sh/uv/install.sh | sh

# Criar ambiente virtual (autom√°tico)
uv venv

# Instalar depend√™ncias (ultrarr√°pido!)
uv pip install -r requirements.txt

# Sincronizar depend√™ncias
uv pip sync requirements.txt

# Listar depend√™ncias instaladas
uv pip list
```

#### Benef√≠cios para Desenvolvimento
- **Setup mais r√°pido**: Projetos s√£o configurados em segundos
- **Consist√™ncia**: Mesmo ambiente em diferentes m√°quinas
- **Isolamento**: Depend√™ncias completamente isoladas
- **Reprodutibilidade**: Environments id√™nticos garantidos

### CodeRabbit (Revis√£o Autom√°tica)
O projeto utiliza **CodeRabbit** para revis√µes autom√°ticas de c√≥digo com as seguintes configura√ß√µes:

#### Configura√ß√µes Principais (.coderabbit.yaml)
```yaml
language: "pt-BR"  # Revis√µes em portugu√™s brasileiro
profile: "chill"   # Perfil relaxado
auto_review:
  enabled: true    # Revis√µes autom√°ticas ativadas
  auto_incremental_review: true  # Revis√µes incrementais
```

#### Funcionalidades Ativadas
- ‚úÖ **Resumos de alto n√≠vel** das mudan√ßas
- ‚úÖ **Estimativa de esfor√ßo** de revis√£o
- ‚úÖ **Diagramas de sequ√™ncia** para fluxos complexos
- ‚úÖ **Avalia√ß√£o de issues** relacionadas
- ‚úÖ **Sugest√µes de labels** autom√°ticas
- ‚úÖ **Gera√ß√£o autom√°tica de t√≠tulos** para PRs
- ‚úÖ **Poemas** criativos em revis√µes

### Ferramentas Python

#### Ruff (Linting e Formata√ß√£o)
**Ruff** √© a ferramenta principal de linting e formata√ß√£o:

```bash
# Instala√ß√£o
pip install ruff

# Verifica√ß√£o de c√≥digo
ruff check .

# Formata√ß√£o autom√°tica
ruff format .

# Corre√ß√£o autom√°tica de problemas
ruff check --fix .
```

#### Flake8 (Linting Estilo PEP 8)
**Flake8** complementa o Ruff com verifica√ß√µes espec√≠ficas:

```bash
# Instala√ß√£o
pip install flake8

# Verifica√ß√£o
flake8 . --max-line-length=88 --extend-ignore=E203,W503
```

#### Pylint (An√°lise Est√°tica Avan√ßada)
**Pylint** para an√°lise mais profunda:

```bash
# Instala√ß√£o
pip install pylint

# An√°lise
pylint extract_links.py exemplo_uso.py --disable=C0103,C0114,C0115,C0116
```

### Ferramentas de Seguran√ßa

#### Gitleaks (Detec√ß√£o de Secrets)
**Gitleaks** verifica se n√£o h√° credenciais vazadas:

```bash
# Instala√ß√£o
brew install gitleaks  # macOS
# ou
pip install gitleaks

# Verifica√ß√£o
gitleaks detect -v
```

### Ferramentas de Documenta√ß√£o

#### LanguageTool (Corre√ß√£o Ortogr√°fica)
**LanguageTool** para verifica√ß√£o de portugu√™s em coment√°rios e docstrings:

```bash
# Verifica√ß√µes ativadas no CodeRabbit
languagetool:
  enabled: true
  level: "default"
```

## üìè Padr√µes de C√≥digo

### Estrutura de Arquivos Python

#### Imports Organizados
```python
# 1. Imports padr√£o da biblioteca
import logging
import time
from datetime import datetime

# 2. Imports de terceiros
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
import yaml
import json

# 3. Imports locais
from my_module import MyClass
```

#### Fun√ß√µes com Docstrings Completas
```python
def extract_links_from_page(url: str, category_name: str) -> list:
    """
    Extrai links de uma p√°gina espec√≠fica usando Selenium.

    Args:
        url: URL da p√°gina a ser analisada
        category_name: Nome da categoria para logging

    Returns:
        Lista de dicion√°rios com links extra√≠dos

    Raises:
        Exception: Quando h√° erro na extra√ß√£o

    Example:
        >>> links = extract_links_from_page("https://example.com", "Teste")
        >>> print(f"Encontrados {len(links)} links")
    """
```

### Conven√ß√µes de Nomenclatura

#### Vari√°veis e Fun√ß√µes
```python
# ‚úÖ Correto
def extract_prompt_links(url, category_name):
    prompt_links = []
    max_retries = 3

# ‚ùå Incorreto
def extractPromptLinks(URL, categoryName):
    PROMPT_LINKS = []
    MAX_RETRIES = 3
```

#### Classes
```python
# ‚úÖ Correto
class WebScraper:
    """Classe base para web scraping."""

# ‚ùå Incorreto
class web_scraper:
    """Classe base para web scraping."""
```

### Tratamento de Erros

#### Try-Except Estruturado
```python
def safe_web_request(url: str, timeout: int = 30) -> dict:
    """Faz requisi√ß√£o web com tratamento robusto de erros."""
    try:
        response = requests.get(url, timeout=timeout)
        response.raise_for_status()
        return {"success": True, "data": response.json()}
    except requests.Timeout:
        logging.error(f"Timeout na requisi√ß√£o para {url}")
        return {"success": False, "error": "timeout"}
    except requests.HTTPError as e:
        logging.error(f"Erro HTTP {e.response.status_code} para {url}")
        return {"success": False, "error": "http_error", "status_code": e.response.status_code}
    except requests.RequestException as e:
        logging.error(f"Erro de rede para {url}: {e}")
        return {"success": False, "error": "network_error"}
    except json.JSONDecodeError:
        logging.error(f"Resposta inv√°lida (n√£o JSON) para {url}")
        return {"success": False, "error": "invalid_json"}
    except Exception as e:
        logging.error(f"Erro inesperado para {url}: {e}")
        return {"success": False, "error": "unexpected_error"}
```

## üîç An√°lise Est√°tica

### Configura√ß√£o do Ruff
Crie um arquivo `pyproject.toml` na raiz do projeto:

```toml
[tool.ruff]
line-length = 88
target-version = "py38"

[tool.ruff.lint]
select = [
    "E",  # pycodestyle errors
    "W",  # pycodestyle warnings
    "F",  # pyflakes
    "I",  # isort
    "B",  # flake8-bugbear
    "C4", # flake8-comprehensions
    "UP", # pyupgrade
]

ignore = [
    "E203",  # whitespace before ':'
    "E501",  # line too long
    "W503",  # line break before binary operator
]

[tool.ruff.lint.isort]
known-first-party = ["godofprompt"]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
line-ending = "auto"
```

### Configura√ß√£o do Flake8
Arquivo `.flake8`:

```ini
[flake8]
max-line-length = 88
extend-ignore = E203, W503
exclude =
    .git,
    __pycache__,
    venv,
    .venv,
    build,
    dist,
    *.egg-info
per-file-ignores =
    __init__.py:F401
```

## üß™ Testes Automatizados

### Estrutura de Testes
```
tests/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ test_extract_links.py
‚îú‚îÄ‚îÄ test_login_automation.py
‚îú‚îÄ‚îÄ test_anti_blocking.py
‚îî‚îÄ‚îÄ conftest.py
```

### Exemplo de Teste
```python
import pytest
from unittest.mock import Mock, patch
from extract_links import extract_links_from_page

class TestExtractLinks:
    """Testes para a fun√ß√£o extract_links_from_page."""

    @patch('extract_links.webdriver.Chrome')
    def test_extract_links_success(self, mock_chrome):
        """Testa extra√ß√£o bem-sucedida de links."""
        # Arrange
        mock_driver = Mock()
        mock_chrome.return_value = mock_driver

        mock_driver.execute_script.return_value = [
            {"url": "https://example.com/prompt1", "name": "Prompt 1"},
            {"url": "https://example.com/prompt2", "name": "Prompt 2"}
        ]

        # Act
        result = extract_links_from_page("https://example.com", "Teste")

        # Assert
        assert len(result) == 2
        assert result[0]["name"] == "Prompt 1"
        assert "example.com" in result[0]["url"]

    @patch('extract_links.webdriver.Chrome')
    def test_extract_links_timeout(self, mock_chrome):
        """Testa tratamento de timeout."""
        # Arrange
        mock_driver = Mock()
        mock_chrome.return_value = mock_driver
        mock_driver.execute_script.side_effect = TimeoutException()

        # Act & Assert
        with pytest.raises(Exception):
            extract_links_from_page("https://example.com", "Teste")
```

### Execu√ß√£o de Testes
```bash
# Instalar pytest
pip install pytest pytest-cov

# Executar testes
pytest tests/

# Com cobertura
pytest --cov=godofprompt tests/ --cov-report=html

# Testes espec√≠ficos
pytest tests/test_extract_links.py::TestExtractLinks::test_extract_links_success -v
```

## üìä M√©tricas de Qualidade

### CodeRabbit Metrics
O CodeRabbit fornece m√©tricas autom√°ticas:

- **Taxa de docstrings**: > 80%
- **Complexidade ciclom√°tica**: < 10
- **Cobertura de testes**: > 70%
- **D√≠vida t√©cnica**: Monitorada automaticamente

### M√©tricas Personalizadas
```python
def calculate_code_metrics():
    """Calcula m√©tricas de qualidade do c√≥digo."""
    import radon.complexity as cc
    import radon.metrics as metrics

    # Complexidade ciclom√°tica
    complexity = cc.average_complexity('extract_links.py')
    print(f"Complexidade m√©dia: {complexity}")

    # M√©tricas de manutenibilidade
    mi = metrics.mi_parameters('extract_links.py')
    print(f"√çndice de manutenibilidade: {mi}")

    # Contagem de linhas
    with open('extract_links.py', 'r') as f:
        lines = f.readlines()
        code_lines = [line for line in lines if line.strip() and not line.strip().startswith('#')]
        print(f"Linhas de c√≥digo: {len(code_lines)}")
        print(f"Total de linhas: {len(lines)}")
```

## üöÄ Integra√ß√£o CI/CD

### GitHub Actions Workflow
```yaml
name: Code Quality

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  quality:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.8'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install ruff flake8 pylint pytest pytest-cov

    - name: Run Ruff
      run: ruff check .

    - name: Run Flake8
      run: flake8 .

    - name: Run Pylint
      run: pylint extract_links.py --disable=C0103,C0114,C0115,C0116

    - name: Run tests
      run: pytest tests/ --cov=. --cov-report=xml

    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
```

### Pre-commit Hooks
Arquivo `.pre-commit-config.yaml`:

```yaml
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.4.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files

  - repo: https://github.com/psf/black
    rev: 22.3.0
    hooks:
      - id: black
        language_version: python3

  - repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
      - id: isort
        args: ["--profile", "black"]

  - repo: https://github.com/pycqa/flake8
    rev: 4.0.1
    hooks:
      - id: flake8

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v0.991
    hooks:
      - id: mypy
        additional_dependencies: [types-all]
```

## üìà Monitoramento Cont√≠nuo

### Dashboard de Qualidade
```python
class QualityDashboard:
    """Dashboard para monitoramento de qualidade de c√≥digo."""

    def __init__(self):
        self.metrics = {}

    def collect_metrics(self):
        """Coleta m√©tricas atuais."""
        # Ruff violations
        # Test coverage
        # Complexity metrics
        # Documentation coverage
        pass

    def generate_report(self):
        """Gera relat√≥rio de qualidade."""
        report = {
            'timestamp': datetime.now().isoformat(),
            'ruff_violations': self._count_ruff_violations(),
            'test_coverage': self._get_test_coverage(),
            'complexity_score': self._calculate_complexity(),
            'documentation_coverage': self._calculate_doc_coverage(),
            'recommendations': self._generate_recommendations()
        }
        return report

    def _generate_recommendations(self):
        """Gera recomenda√ß√µes baseadas nas m√©tricas."""
        recommendations = []

        if self.metrics.get('ruff_violations', 0) > 10:
            recommendations.append("Executar 'ruff check --fix .' para corrigir viola√ß√µes")

        if self.metrics.get('test_coverage', 0) < 70:
            recommendations.append("Aumentar cobertura de testes para pelo menos 70%")

        if self.metrics.get('complexity_score', 0) > 8:
            recommendations.append("Refatorar fun√ß√µes com alta complexidade ciclom√°tica")

        return recommendations
```

## üéØ Melhores Pr√°ticas

### Checklist de Qualidade
- [ ] **Ruff**: `ruff check . && ruff format .`
- [ ] **Flake8**: `flake8 .`
- [ ] **Pylint**: `pylint *.py`
- [ ] **Testes**: `pytest tests/ --cov=.`
- [ ] **Docstrings**: Todas as fun√ß√µes p√∫blicas documentadas
- [ ] **Type hints**: Usar type hints quando poss√≠vel
- [ ] **Logs**: Logging apropriado em todas as opera√ß√µes cr√≠ticas

### Revis√£o de C√≥digo
- ‚úÖ **Funcionalidade**: O c√≥digo funciona como esperado?
- ‚úÖ **Legibilidade**: O c√≥digo √© f√°cil de entender?
- ‚úÖ **Manutenibilidade**: O c√≥digo √© f√°cil de modificar?
- ‚úÖ **Performance**: O c√≥digo √© eficiente?
- ‚úÖ **Seguran√ßa**: N√£o h√° vulnerabilidades √≥bvias?
- ‚úÖ **Testes**: H√° testes adequados?
- ‚úÖ **Documenta√ß√£o**: O c√≥digo est√° bem documentado?

### Padr√µes de Commit
```bash
# Formato recomendado
type(scope): description

# Exemplos
feat(scraper): adicionar extra√ß√£o de conte√∫do completo
fix(login): corrigir timeout no login autom√°tico
docs(readme): atualizar guia de instala√ß√£o
test(scraper): adicionar testes para fun√ß√£o extract_links
refactor(anti-blocking): melhorar sistema de delays adaptativos
```

---

## üèÜ Resultado Esperado

Com essas ferramentas e pr√°ticas implementadas, o projeto GodOfPrompt Scraper ter√°:

- ‚úÖ **C√≥digo consistente** seguindo PEP 8
- ‚úÖ **Qualidade garantida** por ferramentas automatizadas
- ‚úÖ **Revis√µes eficientes** com CodeRabbit
- ‚úÖ **Testes abrangentes** com alta cobertura
- ‚úÖ **Documenta√ß√£o completa** e atualizada
- ‚úÖ **Manutenibilidade** simplificada
- ‚úÖ **Colabora√ß√£o** facilitada

**üéØ Meta**: Taxa de aprova√ß√£o de 95% nas revis√µes autom√°ticas e zero viola√ß√µes cr√≠ticas de qualidade.
