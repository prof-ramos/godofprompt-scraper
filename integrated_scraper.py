#!/usr/bin/env python3
"""
Scraper integrado com sistema de armazenamento inteligente
Combina extra√ß√£o de links/conte√∫do com organiza√ß√£o autom√°tica de arquivos
"""

import os
import sys
import time
import logging
import json
from typing import Dict, List, Optional, Any
from datetime import datetime
from pathlib import Path

# Importar todos os m√≥dulos desenvolvidos
from extract_links import load_categories, extract_category_links, create_driver
from login_automation import create_login_system
from prompt_content_scraper import PromptContentExtractor, PromptData
from storage_manager import create_storage_system, StorageConfig
from monitoring_system import create_monitoring_system
from performance_optimizer import OptimizedScraper
from anti_blocking_strategy import create_enhanced_scraper


class IntegratedGodOfPromptScraper:
    """Scraper completo e integrado do GodOfPrompt.ai"""
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = self._setup_config(config or {})
        
        # Componentes do sistema
        self.storage_system = None
        self.login_system = None
        self.content_extractor = None
        self.monitoring_system = None
        self.performance_optimizer = None
        
        # Estado da execu√ß√£o
        self.execution_stats = {
            'start_time': time.time(),
            'phase': 'initialization',
            'categories_processed': 0,
            'links_extracted': 0,
            'prompts_extracted': 0,
            'files_saved': 0
        }
        
        self._setup_logging()
        self._initialize_systems()
    
    def _setup_config(self, user_config: Dict) -> Dict:
        """Configura par√¢metros do sistema"""
        default_config = {
            # Comportamento geral
            'extract_content': True,          # Se deve extrair conte√∫do dos prompts
            'organize_by_category': True,     # Organizar arquivos por categoria
            'create_backups': True,           # Backup de arquivos existentes
            
            # Credenciais (podem vir de vari√°veis de ambiente)
            'email': os.getenv('GODOFPROMPT_EMAIL', ''),
            'password': os.getenv('GODOFPROMPT_PASSWORD', ''),
            'firecrawl_api_key': os.getenv('FIRECRAWL_API_KEY', ''),
            
            # Armazenamento
            'storage_format': 'markdown',     # markdown, json, txt
            'base_directory': 'godofprompt_data',
            
            # Performance
            'max_workers': 3,
            'batch_size': 5,
            'delays': {'min': 3, 'max': 8},
            'use_cache': True,
            
            # Limites
            'max_pages_per_category': 30,
            'max_retries': 3,
            'session_timeout': 7200,  # 2 horas
            
            # Modo de execu√ß√£o
            'interactive': True,              # Perguntar confirma√ß√µes
            'verbose': True,                  # Logs detalhados
            'test_mode': False,               # Apenas algumas categorias para teste
        }
        
        # Combinar configura√ß√µes
        config = {**default_config, **user_config}
        
        return config
    
    def _setup_logging(self):
        """Configura sistema de logging"""
        log_level = logging.DEBUG if self.config['verbose'] else logging.INFO
        
        logging.basicConfig(
            level=log_level,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(
                    os.path.join(self.config['base_directory'], 'integrated_scraper.log')
                ),
                logging.StreamHandler()
            ]
        )
        
        # Criar diret√≥rio de logs se n√£o existe
        Path(self.config['base_directory']).mkdir(exist_ok=True)
    
    def _initialize_systems(self):
        """Inicializa todos os sistemas necess√°rios"""
        logging.info("üîß Inicializando sistemas integrados...")
        
        # 1. Sistema de armazenamento
        storage_config = StorageConfig(
            base_dir=self.config['base_directory'],
            organize_by_category=self.config['organize_by_category'],
            prompt_format=self.config['storage_format'],
            create_backups=self.config['create_backups']
        )
        
        self.storage_system = create_storage_system(
            organize_by_category=self.config['organize_by_category'],
            prompt_format=self.config['storage_format']
        )
        
        # 2. Sistema de login (se credenciais fornecidas)
        if self.config['email'] and self.config['password']:
            try:
                self.login_system = create_login_system(
                    self.config['email'], 
                    self.config['password']
                )
                logging.info("‚úÖ Sistema de login inicializado")
            except Exception as e:
                logging.warning(f"‚ö†Ô∏è  Falha no sistema de login: {e}")
        
        # 3. Sistema de monitoramento
        self.monitoring_system = create_monitoring_system()
        self.monitoring_system['start']()
        
        # 4. Otimizador de performance
        perf_config = {
            'batch_size': self.config['batch_size'],
            'max_workers': self.config['max_workers'],
            'use_cache': self.config['use_cache'],
            'monitor_resources': True
        }
        
        self.performance_optimizer = OptimizedScraper(perf_config)
        
        # 5. Extrator de conte√∫do (se necess√°rio)
        if self.config['extract_content']:
            self.content_extractor = PromptContentExtractor(
                login_system=self.login_system,
                monitor=self.monitoring_system['monitor']
            )
        
        logging.info("‚úÖ Todos os sistemas inicializados")
    
    def run_complete_extraction(self) -> Dict[str, Any]:
        """Executa extra√ß√£o completa - links + conte√∫do + armazenamento"""
        
        print("üöÄ === SCRAPER INTEGRADO GODOFPROMPT.AI ===\n")
        
        try:
            # Fase 1: Carregar categorias e configurar
            categories = self._load_and_configure_categories()
            
            # Fase 2: Extra√ß√£o de links
            links_data = self._extract_all_links(categories)
            
            # Fase 3: Login e extra√ß√£o de conte√∫do (se habilitado)
            prompts_data = None
            if self.config['extract_content'] and links_data:
                if self._should_extract_content(links_data):
                    prompts_data = self._extract_all_content(links_data)
            
            # Fase 4: Armazenamento inteligente
            storage_results = self._store_results(links_data, prompts_data)
            
            # Fase 5: Relat√≥rio final
            return self._generate_final_report(categories, links_data, prompts_data, storage_results)
            
        except KeyboardInterrupt:
            logging.warning("‚ö†Ô∏è  Execu√ß√£o interrompida pelo usu√°rio")
            return {'status': 'interrupted', 'partial_results': True}
        except Exception as e:
            logging.error(f"‚ùå Erro cr√≠tico na execu√ß√£o: {e}")
            return {'status': 'error', 'error': str(e)}
        finally:
            self._cleanup()
    
    def _load_and_configure_categories(self) -> List[Dict]:
        """Carrega e configura categorias para extra√ß√£o"""
        logging.info("üìã Carregando categorias...")
        
        categories = load_categories()
        
        # Modo teste - apenas algumas categorias
        if self.config['test_mode']:
            categories = categories[:2]  # Apenas 2 primeiras
            logging.info(f"üß™ Modo teste: processando apenas {len(categories)} categorias")
        
        # Exibir categorias
        print(f"\nüìã CATEGORIAS A SEREM PROCESSADAS ({len(categories)}):")
        total_esperado = 0
        for i, cat in enumerate(categories, 1):
            print(f"  {i}. {cat['nome']}: {cat['quantidadeDePrompts']} prompts")
            total_esperado += cat['quantidadeDePrompts']
        
        print(f"\nüìä Total esperado: {total_esperado} prompts")
        
        # Confirma√ß√£o interativa
        if self.config['interactive']:
            continuar = input("\nDeseja continuar? (s/n): ").lower().strip()
            if continuar != 's':
                print("‚ùå Extra√ß√£o cancelada pelo usu√°rio")
                sys.exit(0)
        
        return categories
    
    def _extract_all_links(self, categories: List[Dict]) -> Dict[str, Any]:
        """Extrai todos os links usando sistema otimizado"""
        self.execution_stats['phase'] = 'link_extraction'
        
        print("\nüîó === FASE 1: EXTRA√á√ÉO DE LINKS ===")
        logging.info("Iniciando extra√ß√£o de links...")
        
        # Usar extrator otimizado se dispon√≠vel
        if self.performance_optimizer:
            def extract_wrapper(category):
                return extract_category_links(category)
            
            results = self.performance_optimizer.extract_all_categories(
                categories, extract_wrapper
            )
        else:
            # Fallback para m√©todo tradicional
            results = self._extract_links_traditional(categories)
        
        # Contabilizar resultados
        total_links = sum(len(links) for links in results.values())
        self.execution_stats['links_extracted'] = total_links
        self.execution_stats['categories_processed'] = len(results)
        
        print(f"‚úÖ Extra√ß√£o de links conclu√≠da: {total_links} links extra√≠dos")
        
        return results
    
    def _extract_links_traditional(self, categories: List[Dict]) -> Dict[str, List]:
        """M√©todo tradicional de extra√ß√£o de links (fallback)"""
        results = {}
        driver = create_driver()
        
        try:
            for i, category in enumerate(categories, 1):
                print(f"\nüîÑ [{i}/{len(categories)}] {category['nome']}")
                
                links = extract_category_links(category, driver, should_close_driver=False)
                results[category['nome']] = links
                
                print(f"‚úÖ {len(links)} links extra√≠dos")
                time.sleep(2)  # Pausa entre categorias
        finally:
            if driver:
                driver.quit()
        
        return results
    
    def _should_extract_content(self, links_data: Dict) -> bool:
        """Decide se deve extrair conte√∫do dos prompts"""
        total_links = sum(len(links) for links in links_data.values())
        
        if not self.config['extract_content']:
            return False
        
        if not self.login_system:
            print("‚ö†Ô∏è  Sistema de login n√£o configurado - pulando extra√ß√£o de conte√∫do")
            return False
        
        # Confirma√ß√£o para muitos prompts
        if self.config['interactive'] and total_links > 100:
            print(f"\nü§î Foram encontrados {total_links} prompts")
            print("‚ö†Ô∏è  A extra√ß√£o de conte√∫do pode demorar muito tempo!")
            
            if not self.config['test_mode']:
                continuar = input("Deseja continuar com extra√ß√£o de conte√∫do? (s/n): ").lower().strip()
                if continuar != 's':
                    return False
        
        return True
    
    def _extract_all_content(self, links_data: Dict) -> List[PromptData]:
        """Extrai conte√∫do completo de todos os prompts"""
        self.execution_stats['phase'] = 'content_extraction'
        
        print("\nüìù === FASE 2: EXTRA√á√ÉO DE CONTE√öDO ===")
        logging.info("Iniciando extra√ß√£o de conte√∫do...")
        
        # Login autom√°tico
        if self.login_system:
            print("üîê Realizando login...")
            success, session_data = self.login_system.perform_login(use_headless=True)
            
            if not success:
                print("‚ùå Falha no login - pulando extra√ß√£o de conte√∫do")
                return None
            
            print("‚úÖ Login realizado com sucesso")
        
        # Preparar lista de URLs
        all_urls = []
        for category_name, links in links_data.items():
            for link_data in links:
                all_urls.append({
                    'url': link_data['url'],
                    'id': link_data.get('id', 'unknown'),
                    'category': category_name,
                    'name': link_data.get('name', 'Sem t√≠tulo')
                })
        
        # Extrair conte√∫do
        if self.content_extractor:
            prompts_data = self.content_extractor.extract_multiple_prompts(
                all_urls, max_workers=self.config['max_workers']
            )
        else:
            print("‚ùå Extrator de conte√∫do n√£o inicializado")
            return None
        
        # Contabilizar
        successful_extractions = sum(1 for p in prompts_data if p.success)
        self.execution_stats['prompts_extracted'] = successful_extractions
        
        print(f"‚úÖ Extra√ß√£o de conte√∫do conclu√≠da: {successful_extractions}/{len(all_urls)}")
        
        return prompts_data
    
    def _store_results(self, links_data: Dict, prompts_data: List[PromptData] = None) -> Dict[str, Any]:
        """Armazena resultados no sistema de arquivos"""
        self.execution_stats['phase'] = 'storage'
        
        print("\nüíæ === FASE 3: ARMAZENAMENTO ===")
        logging.info("Iniciando armazenamento de dados...")
        
        storage_results = {'files_created': [], 'directories_created': []}
        
        # Armazenar prompts completos (se dispon√≠veis)
        if prompts_data:
            print("üìÑ Salvando prompts completos em arquivos individuais...")
            
            # Converter PromptData para dict
            prompts_dict = [prompt.to_dict() for prompt in prompts_data]
            
            # Salvar usando sistema de armazenamento
            prompt_files = self.storage_system.prompt_storage.save_multiple_prompts(prompts_dict)
            storage_results['files_created'].extend(prompt_files)
            
            print(f"‚úÖ {len(prompt_files)} arquivos de prompt salvos")
        
        # Salvar links (sempre, como fallback/backup)
        if links_data:
            print("üîó Salvando links em arquivo YAML...")
            
            # Preparar dados para o formato esperado
            formatted_links_data = {}
            for category, links in links_data.items():
                formatted_links_data[category] = links
            
            links_file = self.storage_system.links_storage.save_links_by_category(formatted_links_data)
            storage_results['files_created'].append(links_file)
            
            print(f"‚úÖ Links salvos em: {os.path.basename(links_file)}")
        
        # Salvar metadados da execu√ß√£o
        metadata = self._generate_execution_metadata()
        metadata_file = self._save_execution_metadata(metadata)
        storage_results['files_created'].append(metadata_file)
        
        self.execution_stats['files_saved'] = len(storage_results['files_created'])
        
        return storage_results
    
    def _generate_execution_metadata(self) -> Dict:
        """Gera metadados da execu√ß√£o atual"""
        current_time = time.time()
        
        return {
            'execution_info': {
                'start_time': datetime.fromtimestamp(self.execution_stats['start_time']).isoformat(),
                'end_time': datetime.fromtimestamp(current_time).isoformat(),
                'duration_seconds': current_time - self.execution_stats['start_time'],
                'phase': self.execution_stats['phase']
            },
            'statistics': {
                'categories_processed': self.execution_stats['categories_processed'],
                'links_extracted': self.execution_stats['links_extracted'],
                'prompts_extracted': self.execution_stats['prompts_extracted'],
                'files_saved': self.execution_stats['files_saved']
            },
            'configuration': {
                'extract_content': self.config['extract_content'],
                'storage_format': self.config['storage_format'],
                'organize_by_category': self.config['organize_by_category'],
                'test_mode': self.config['test_mode']
            },
            'system_info': {
                'python_version': sys.version,
                'storage_directory': self.config['base_directory']
            }
        }
    
    def _save_execution_metadata(self, metadata: Dict) -> str:
        """Salva metadados da execu√ß√£o"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"execution_metadata_{timestamp}.json"
        filepath = os.path.join(self.config['base_directory'], 'metadata', filename)
        
        # Garantir que diret√≥rio existe
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, ensure_ascii=False, indent=2)
        
        return filepath
    
    def _generate_final_report(self, categories: List[Dict], links_data: Dict, 
                              prompts_data: List[PromptData], storage_results: Dict) -> Dict[str, Any]:
        """Gera relat√≥rio final da execu√ß√£o"""
        
        print("\nüéâ === RELAT√ìRIO FINAL ===")
        
        # Estat√≠sticas b√°sicas
        total_expected = sum(cat['quantidadeDePrompts'] for cat in categories)
        total_links = sum(len(links) for links in links_data.values()) if links_data else 0
        total_prompts = len([p for p in prompts_data if p.success]) if prompts_data else 0
        
        duration = time.time() - self.execution_stats['start_time']
        
        # Exibir relat√≥rio
        print(f"‚è±Ô∏è  Tempo total: {duration/60:.1f} minutos")
        print(f"üìÇ Diret√≥rio: {self.config['base_directory']}")
        print(f"üìä Categorias processadas: {len(categories)}")
        print(f"üîó Links extra√≠dos: {total_links}/{total_expected} ({(total_links/max(total_expected,1))*100:.1f}%)")
        
        if prompts_data:
            print(f"üìù Prompts completos: {total_prompts}/{total_links} ({(total_prompts/max(total_links,1))*100:.1f}%)")
        
        print(f"üíæ Arquivos criados: {len(storage_results['files_created'])}")
        
        # Estat√≠sticas por categoria
        if links_data:
            print("\nüìà Detalhes por categoria:")
            for category in categories:
                cat_name = category['nome']
                expected = category['quantidadeDePrompts']
                extracted = len(links_data.get(cat_name, []))
                percentage = (extracted / max(expected, 1)) * 100
                print(f"  ‚Ä¢ {cat_name}: {extracted}/{expected} ({percentage:.1f}%)")
        
        # Performance do sistema
        if self.monitoring_system:
            dashboard = self.monitoring_system['dashboard']()
            print(f"\n‚ö° Performance:")
            print(f"  ‚Ä¢ Taxa de sucesso: {dashboard['performance']['success_rate']:.1%}")
            print(f"  ‚Ä¢ Tempo m√©dio/requisi√ß√£o: {dashboard['performance']['avg_response_time']:.1f}s")
        
        # Localiza√ß√£o dos arquivos
        print(f"\nüìÅ Arquivos salvos em:")
        print(f"  ‚Ä¢ Base: {self.config['base_directory']}/")
        
        if prompts_data:
            print(f"  ‚Ä¢ Prompts: {self.config['base_directory']}/prompts/")
        if links_data:
            print(f"  ‚Ä¢ Links: {self.config['base_directory']}/links/")
        
        # Estrutura do relat√≥rio para retorno
        report = {
            'status': 'completed',
            'duration_minutes': duration / 60,
            'statistics': {
                'total_expected': total_expected,
                'links_extracted': total_links,
                'prompts_extracted': total_prompts,
                'categories_processed': len(categories),
                'files_created': len(storage_results['files_created'])
            },
            'storage': {
                'base_directory': self.config['base_directory'],
                'files_created': storage_results['files_created']
            },
            'performance': self.monitoring_system['dashboard']() if self.monitoring_system else None
        }
        
        return report
    
    def _cleanup(self):
        """Limpa recursos utilizados"""
        logging.info("üßπ Limpando recursos...")
        
        if self.monitoring_system:
            self.monitoring_system['stop']()
        
        if self.login_system:
            self.login_system.cleanup()
        
        logging.info("‚úÖ Limpeza conclu√≠da")


# Fun√ß√µes de conveni√™ncia para uso f√°cil
def run_links_only_extraction(test_mode: bool = False) -> Dict[str, Any]:
    """Executa apenas extra√ß√£o de links"""
    config = {
        'extract_content': False,
        'test_mode': test_mode,
        'interactive': True
    }
    
    scraper = IntegratedGodOfPromptScraper(config)
    return scraper.run_complete_extraction()


def run_full_extraction(email: str = None, password: str = None, 
                       test_mode: bool = False) -> Dict[str, Any]:
    """Executa extra√ß√£o completa (links + conte√∫do)"""
    config = {
        'extract_content': True,
        'email': email or os.getenv('GODOFPROMPT_EMAIL', ''),
        'password': password or os.getenv('GODOFPROMPT_PASSWORD', ''),
        'test_mode': test_mode,
        'interactive': True,
        'storage_format': 'markdown',
        'organize_by_category': True
    }
    
    scraper = IntegratedGodOfPromptScraper(config)
    return scraper.run_complete_extraction()


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    # An√°lise de argumentos simples
    test_mode = '--test' in sys.argv
    links_only = '--links-only' in sys.argv
    
    print("üöÄ GodOfPrompt.ai - Scraper Integrado")
    print("=" * 50)
    
    if links_only:
        print("üîó Modo: Apenas Links")
        result = run_links_only_extraction(test_mode)
    else:
        print("üìù Modo: Extra√ß√£o Completa")
        result = run_full_extraction(test_mode=test_mode)
    
    if result.get('status') == 'completed':
        print("\nüéâ Execu√ß√£o conclu√≠da com sucesso!")
    else:
        print(f"\n‚ö†Ô∏è  Execu√ß√£o finalizada com status: {result.get('status')}")